import lingo/pegcode/driver;
import ds/tree;

BoolForm ::= BoolAdd,BoolMult,BoolImpl,BoolNeg,BoolTrue,BoolFalse,BoolVar;
BoolAdd(a1:BoolForm,a2:BoolForm);
BoolMult(a1:BoolForm,a2:BoolForm);
BoolImpl(a1:BoolForm,a2:BoolForm);
BoolNeg(a1:BoolForm);
BoolTrue();
BoolFalse();
BoolVar(a:string);

//парсим строки в формулы
s2bf(str : string) -> BoolForm {
    b_gr = "#include bool.lingo";
    parsic(
        compilePegGrammar(b_gr),
        str,
        defaultPegActions
    )
}

//записываем формулы в строки
bf2s(f : BoolForm) -> string {
    switch (f) {
        BoolAdd(a1,a2): "(" + bf2s(a1) + "\\/" +  bf2s(a2) + ")";
        BoolMult(a1,a2): "(" + bf2s(a1) + "/\\" +  bf2s(a2) + ")";
        BoolImpl(a1,a2): "(" + bf2s(a1) + "->" + bf2s(a2) + ")";
        BoolNeg(a1): "Not_"  + bf2s(a1);
        BoolTrue(): "T";
        BoolFalse(): "F";
        BoolVar(a): a;
    }
}

//находим переменные в формуле
favit(f : BoolForm) -> [string] {
        switch (f) {
        BoolAdd(a1,a2): concatA([favit(a1),favit(a2)]);
        BoolMult(a1,a2): concatA([favit(a1),favit(a2)]);
        BoolImpl(a1,a2): concatA([favit(a1),favit(a2)]);
        BoolNeg(a1): favit(a1);
        BoolTrue(): [];
        BoolFalse(): [];
        BoolVar(a): [a];
    }
}

//записываем переменные из формулы в дерево с дефолтным значением true
bf2t(f : BoolForm) -> Tree<string, bool> {
    mas = favit(f);
    new_tree = makeTree();
    g = \t,e->setTree(t,e, true);
    fold(mas, new_tree, g);
}

//ищем значение по дереву с дефолтным значением true
tiv(t : Tree<string, bool>, s : string) -> bool {
    lookupTreeDef(t, s, true);
}

//вычисляем формулы
evf(f : BoolForm, t : Tree<string, bool>) -> bool {
        switch (f) {
        BoolAdd(a1,a2): evf(a1,t)||evf(a2,t);
        BoolMult(a1,a2):  evf(a1,t)&&evf(a2,t);
        BoolImpl(a1,a2): evf(a1,t)->evf(a2,t);
        BoolNeg(a1): !evf(a1,t);
        BoolTrue(): true;
        BoolFalse(): false;
        BoolVar(a): tiv(t,a);
    }    
}


main() {
    x = "((z\\/x)/\\((F/\\T)->(x\\/Not_y)))";
    form = s2bf(x);
    str = bf2s(form);
    vars = bf2t(form);
    out = evf(form, vars);
    println(str);
    println(vars);
    println(out);

}
