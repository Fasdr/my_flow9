import lingo/pegcode/driver;

import ds/array;
import ds/set;
import ds/tree;


FOLTerm ::= FOLVar, FOLFunc;

FOLVar(name : string);
FOLFunc(name : string, variables : [FOLTerm]);

FOLForm ::= FOLPred, FOLEq, FOLAll, FOLExist, FOLCon, FOLDis, FOLImpl, FOLNeg;

FOLPred(name : string, variables : [FOLTerm]);
FOLEq(term1 : FOLTerm, term2 : FOLTerm);
FOLAll(bound : FOLVar, form : FOLForm);
FOLExist(bound : FOLVar, form : FOLForm);
FOLCon(form1 : FOLForm, form2 : FOLForm);
FOLDis(form1 : FOLForm, form2 : FOLForm);
FOLImpl(form1 : FOLForm, form2 : FOLForm);
FOLNeg(form : FOLForm);

//глобальные переменные для скорости
curnumbofvars = ref 0;

quants: ref [FOLForm] = ref [];




//парсим строки в формулы
s2pf(str : string) -> FOLForm {
    b_gr = "#include FOLparse.lingo";
    parsic(
        compilePegGrammar(b_gr),
        str,
        defaultPegActions
    )
}

//записываем термы в строки
t2s(tterm : FOLTerm) -> string {
    switch (tterm) {
        FOLVar(name): name;    
        FOLFunc(name, variables): name + "(" + strGlue(map(variables,t2s), ",") + ")";
    }
}

//записываем формулы в строки
pf2s(fform : FOLForm) -> string {
    switch (fform) {
        FOLPred(name, variables): name + "(" + strGlue(map(variables,t2s), ",") + ")";
        FOLEq(term1, term2): t2s(term1) + "=" + t2s(term2);
        FOLAll(bound, form): "A_" + t2s(bound) + "." + pf2s(form);
        FOLExist(bound, form): "E_" + t2s(bound) + "." + pf2s(form);
        FOLCon(form1, form2): "(" + pf2s(form1) +  "/\\"  + pf2s(form2) + ")";
        FOLDis(form1, form2): "(" + pf2s(form1) +  "\\/"  + pf2s(form2) + ")";
        FOLImpl(form1, form2): "(" + pf2s(form1) +  "->"  + pf2s(form2) + ")";
        FOLNeg(form): "Not_"  + pf2s(form);
    }
}

//даем переменным уникальные имена 
newvar() -> FOLVar {
    curnumbofvars := ^curnumbofvars + 1 ;
    FOLVar("x"+i2s(^curnumbofvars));
}

nshortcutall(fform : FOLAll, t : Tree<FOLVar, FOLVar>) -> FOLAll {
    nvar = newvar();
    FOLAll(nvar, befrenamevarsinform(fform.form, setTree(t, fform.bound, nvar)));
}

nshortcutexist(fform : FOLExist, t : Tree<FOLVar, FOLVar>) -> FOLExist {
    nvar = newvar();
    FOLExist(nvar, befrenamevarsinform(fform.form, setTree(t, fform.bound, nvar)));
}

befrenamevarsinform(fform : FOLForm, t : Tree<FOLVar, FOLVar>) -> FOLForm {
    g = \x -> befrenamevarsinterm(x, t);
    switch (fform) {
        FOLPred(name, variables): FOLPred(name,  map(variables,g));
        FOLEq(term1, term2): FOLEq(befrenamevarsinterm(term1, t), befrenamevarsinterm(term2, t));
        FOLAll(bound, form): nshortcutall(fform, t);
        FOLExist(bound, form): nshortcutexist(fform, t);
        FOLCon(form1, form2): FOLCon(befrenamevarsinform(form1,t), befrenamevarsinform(form2,t));
        FOLDis(form1, form2): FOLDis(befrenamevarsinform(form1,t), befrenamevarsinform(form2,t));
        FOLImpl(form1, form2): FOLImpl(befrenamevarsinform(form1,t), befrenamevarsinform(form2,t));
        FOLNeg(form): FOLNeg(befrenamevarsinform(form,t));
    }
}

befrenamevarsinterm(tterm : FOLTerm, t : Tree<FOLVar, FOLVar>) -> FOLTerm {
    g = \x -> befrenamevarsinterm(x, t);
    switch (tterm) {
        FOLVar(name): lookupTreeDef(t, FOLVar(name), FOLVar(name));
        FOLFunc(name, variables): FOLFunc(name, map(variables,g));
    }
}

pfuvar(fform : FOLForm) -> FOLForm {
    befrenamevarsinform(fform, makeTree());
}





//вытаскиваем кванторы, убираем импликации, вносим отрицание
ishortcutexist(fform : FOLExist, out : FOLForm) -> FOLForm {
    quants := arrayPush(^quants, FOLExist(fform.bound,FOLPred("SOME",[])));
    out;
}

ishortcutall(fform : FOLAll, out : FOLForm) -> FOLForm {
    quants := arrayPush(^quants, FOLAll(fform.bound,FOLPred("SOME",[])));
    out;
}

pfbpr(fform : FOLForm) -> FOLForm {
    switch (fform) {
        FOLPred(name, variables): fform;
        FOLEq(term1, term2): fform;
        FOLAll(bound, form): pfbpr(ishortcutall(fform, form));
        FOLExist(bound, form): pfbpr(ishortcutexist(fform, form));
        FOLCon(form1, form2): FOLCon(pfbpr(form1), pfbpr(form2));
        FOLDis(form1, form2): FOLDis(pfbpr(form1), pfbpr(form2));
        FOLImpl(form1, form2): pfbpr(FOLDis(FOLNeg(form1),form2));
        FOLNeg(form): fnotpfbpr(form);
    }
}

fnotpfbpr(fform : FOLForm) -> FOLForm {
    switch (fform) {
        FOLPred(name, variables): FOLNeg(fform);
        FOLEq(term1, term2): FOLNeg(fform);
        FOLAll(bound, form): fnotpfbpr(ishortcutexist(FOLExist(bound, form), form));
        FOLExist(bound, form): fnotpfbpr(ishortcutall(FOLAll(bound, form), form));
        FOLCon(form1, form2): FOLDis(fnotpfbpr(form1), fnotpfbpr(form2));
        FOLDis(form1, form2): FOLCon(fnotpfbpr(form1), fnotpfbpr(form2));
        FOLImpl(form1, form2): fnotpfbpr(FOLDis(FOLNeg(form1),form2));
        FOLNeg(form): pfbpr(form);
    }
}




//отрисовка формул 2
myfn(f1 : FOLForm,f2 : FOLForm) -> FOLForm{
    switch (f2) {
        FOLAll(bound, form): FOLAll(bound, f1);
        FOLExist(bound, form): FOLExist(bound, f1);
        default: f1;
    }
}

pf2pf(fform : FOLForm) -> FOLForm {
    foldr(^quants, fform, myfn);
}



main() {
     test5();

}

test1() -> void {
    mystring = "A_x.E_y.Not_(P(g(x))->Q(y))"; 
    println(mystring);
    out = s2pf(mystring);
    println(out);
    println(pf2s(out));
}

test2() -> void {
    //mystring = "A_x.E_y.Not_(P(g(x))->Q(y))"; 
    mystring = "E_y.A_x.(P(x,y,z)/\\E_x.G(x,y,t))";
    println(mystring);
    in = s2pf(mystring);
    out = pfuvar(in);
    println(pf2s(out));
}

test3() -> void { 
    //mystring = "E_y.A_x.(P(x,y,z)/\\E_x.G(x,y,t))";
    //mystring = "Not_A_x.P(x)";
    //mystring = "Not_E_x.P(x)";
    mystring = "(A_x.G(x)->Not_A_x.P(x))";
    println(mystring);
    in = s2pf(mystring);
    out = pfuvar(in);
    println(pf2s(out));
    nout = pfbpr(out);
    println(pf2s(nout));
}

test4() -> void { 
    mystring = "A_x.A_y.(E_z.(P(x,z)/\\P(y,z))->E_u.Q(x,y,u))";
    println(mystring);
    in = s2pf(mystring);
    out = pfuvar(in);
    println(pf2s(out));
    nout = pfbpr(out);
    println(pf2s(nout));
    println(^quants);
}

test5() -> void { 
    mystring = "A_x.A_y.(E_z.(P(x,z)/\\P(y,z))->E_u.Q(x,y,u))";
    println(mystring);
    in = s2pf(mystring);
    out = pfuvar(in);
    nout = pfbpr(out);
    println(pf2s(pf2pf(nout)));
}