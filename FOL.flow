import lingo/pegcode/driver;

import ds/array;
import ds/set;
import ds/tree;


FOLTerm ::= FOLVar, FOLFunc;

FOLVar(name : string);
FOLFunc(name : string, variables : [FOLTerm]);

FOLForm ::= FOLPred, FOLEq, FOLAll, FOLExist, FOLCon, FOLDis, FOLImpl, FOLNeg;

FOLPred(name : string, variables : [FOLTerm]);
FOLEq(term1 : FOLTerm, term2 : FOLTerm);
FOLAll(bound : FOLVar, form : FOLForm);
FOLExist(bound : FOLVar, form : FOLForm);
FOLCon(form1 : FOLForm, form2 : FOLForm);
FOLDis(form1 : FOLForm, form2 : FOLForm);
FOLImpl(form1 : FOLForm, form2 : FOLForm);
FOLNeg(form : FOLForm);

//глобальные переменные для скорости
curnumbofvars = ref 0;

quantall : ref Set<FOLVar> = ref makeSet();

quantexist : ref Set<FOLVar> = ref makeSet();


//парсим строки в формулы
s2pf(str : string) -> FOLForm {
    b_gr = "#include FOLparse.lingo";
    parsic(
        compilePegGrammar(b_gr),
        str,
        defaultPegActions
    )
}

//записываем термы в строки
t2s(tterm : FOLTerm) -> string {
    switch (tterm) {
        FOLVar(name): name;    
        FOLFunc(name, variables): name + "(" + strGlue(map(variables,t2s), ",") + ")";
    }
}

//записываем формулы в строки
pf2s(fform : FOLForm) -> string {
    switch (fform) {
        FOLPred(name, variables): name + "(" + strGlue(map(variables,t2s), ",") + ")";
        FOLEq(term1, term2): t2s(term1) + "=" + t2s(term2);
        FOLAll(bound, form): "A_" + t2s(bound) + "." + pf2s(form);
        FOLExist(bound, form): "E_" + t2s(bound) + "." + pf2s(form);
        FOLCon(form1, form2): "(" + pf2s(form1) +  "/\\"  + pf2s(form2) + ")";
        FOLDis(form1, form2): "(" + pf2s(form1) +  "\\/"  + pf2s(form2) + ")";
        FOLImpl(form1, form2): "(" + pf2s(form1) +  "->"  + pf2s(form2) + ")";
        FOLNeg(form): "Not_"  + pf2s(form);
    }
}

//даем переменным уникальные имена 
newvar() -> FOLVar {
    curnumbofvars := ^curnumbofvars + 1 ;
    FOLVar("x"+i2s(^curnumbofvars));
}

nshortcutall(fform : FOLAll, t : Tree<FOLVar, FOLVar>) -> FOLAll {
    nvar = newvar();
    FOLAll(nvar, befrenamevarsinform(fform.form, setTree(t, fform.bound, nvar)));
}

nshortcutexist(fform : FOLExist, t : Tree<FOLVar, FOLVar>) -> FOLExist {
    nvar = newvar();
    FOLExist(nvar, befrenamevarsinform(fform.form, setTree(t, fform.bound, nvar)));
}

befrenamevarsinform(fform : FOLForm, t : Tree<FOLVar, FOLVar>) -> FOLForm {
    g = \x -> befrenamevarsinterm(x, t);
    switch (fform) {
        FOLPred(name, variables): FOLPred(name,  map(variables,g));
        FOLEq(term1, term2): FOLEq(befrenamevarsinterm(term1, t), befrenamevarsinterm(term2, t));
        FOLAll(bound, form): nshortcutall(fform, t);
        FOLExist(bound, form): nshortcutexist(fform, t);
        FOLCon(form1, form2): FOLCon(befrenamevarsinform(form1,t), befrenamevarsinform(form2,t));
        FOLDis(form1, form2): FOLDis(befrenamevarsinform(form1,t), befrenamevarsinform(form2,t));
        FOLImpl(form1, form2): FOLImpl(befrenamevarsinform(form1,t), befrenamevarsinform(form2,t));
        FOLNeg(form): FOLNeg(befrenamevarsinform(form,t));
    }
}

befrenamevarsinterm(tterm : FOLTerm, t : Tree<FOLVar, FOLVar>) -> FOLTerm {
    g = \x -> befrenamevarsinterm(x, t);
    switch (tterm) {
        FOLVar(name): lookupTreeDef(t, FOLVar(name), FOLVar(name));
        FOLFunc(name, variables): FOLFunc(name, map(variables,g));
    }
}

pfuvar(fform : FOLForm) -> FOLForm {
    befrenamevarsinform(fform, makeTree());
}

//вытаскиваем кванторы, убираем импликации, вносим отрицание
ishortcutall(fform : FOLAll, out : FOLForm) -> FOLForm {
    quantall := insertSet(^quantall, fform.bound);
    out;
}

ishortcutexist(fform : FOLExist, out : FOLForm) -> FOLForm {
    quantexist := insertSet(^quantexist, fform.bound);
    out;
}

pfbpr(fform : FOLForm) -> FOLForm {
    switch (fform) {
        FOLPred(name, variables): fform;
        FOLEq(term1, term2): fform;
        FOLAll(bound, form): 
        FOLExist(bound, form): 
        FOLCon(form1, form2): 
        FOLDis(form1, form2): 
        FOLImpl(form1, form2): 
        FOLNeg(form): 
    }
}

fpfbpr(fform : FOLForm) -> FOLForm {
    switch (fform) {
        FOLPred(name, variables): fform;
        FOLEq(term1, term2): fform;
        FOLAll(bound, form): 
        FOLExist(bound, form): 
        FOLCon(form1, form2): 
        FOLDis(form1, form2): 
        FOLImpl(form1, form2): 
        FOLNeg(form): 
    }
}



main() {
     test2();

}

test1() -> void {
    mystring = "A_x.E_y.Not_(P(g(x))->Q(y))"; 
    println(mystring);
    out = s2pf(mystring);
    println(out);
    println(pf2s(out));
}

test2() -> void {
    //mystring = "A_x.E_y.Not_(P(g(x))->Q(y))"; 
    mystring = "E_y.A_x.(P(x,y,z)/\\E_x.G(x,y,t))";
    println(mystring);
    in = s2pf(mystring);
    out = pfuvar(in);
    println(pf2s(out));
}